initSidebarItems({"enum":[["DefaultApprox","The \"default\" approximation scheme.  This scheme does whatever would generally be expected of a lossy conversion, assuming no additional context or instruction is given.This is a double-edged sword: it has the loosest semantics, but is far more likely to exist than more complicated approximation schemes."],["RoundToNearest","This scheme is used to convert a value by rounding it to the nearest representable value, with ties rounding away from zero."],["RoundToNegInf","This scheme is used to convert a value by rounding it toward negative infinity to the nearest representable value."],["RoundToPosInf","This scheme is used to convert a value by rounding it toward positive infinity to the nearest representable value."],["RoundToZero","This scheme is used to convert a value by rounding it toward zero to the nearest representable value."],["Wrapping","This scheme is used to convert a value by \"wrapping\" it into a narrower range.In abstract, this can be viewed as the opposite of rounding: rather than preserving the most significant bits of a value, it preserves the *least* significant bits of a value."]],"macro":[["TryFrom!","See the documentation for the `macros` module for details."]],"mod":[["errors","This module defines the various error types that can be produced by a failed conversion.In addition, it also defines some extension traits to make working with failable conversions more ergonomic (see the `Unwrap*` traits)."],["macros","This module provides convenience macros to help with implementing the conversion traits.`TryFrom!`This macro attempts to derive an implementation of the `TryFrom` trait.  Specifically, it supports `enum`s consisting entirely of unitary variants, with or without explicit values.  The source type can be any integer type which the variants of the enumeration can be explicitly cast to (*i.e.* using `as`).If a conversion fails (due to there being no matching variant for the specified integer value `src`), then the conversion returns `Err(Unrepresentable(src))` (see `Unrepresentable`).It is compatible with the `custom_derive!` macro.ExampleUsing `custom_derive!`:The above is equivalent to the following:"],["misc","This module defines some additional traits not *directly* tied to conversions."],["prelude","Publicly re-exports the most generally useful set of items.Usage of the prelude should be considered **unstable**.  Although items will likely *not* be removed without bumping the major version, new items *may* be added, which could potentially cause name conflicts in user code."]],"trait":[["ApproxFrom","This trait is used to perform a conversion that is permitted to approximate the result, but *not* to wrap or saturate the result to fit into the destination type's representable range.Where possible, prefer *implementing* this trait over `ApproxInto`, but prefer *using* `ApproxInto` for generic constraints.DetailsAll implementations of this trait must provide a conversion that can be separated into two logical steps: an approximation transform, and a representation transform.The \"approximation transform\" step involves transforming the input value into an approximately equivalent value which is supported by the target type *without* taking the target type's representable range into account.  For example, this might involve rounding or truncating a floating point value to an integer, or reducing the accuracy of a floating point value.The \"representation transform\" step *exactly* rewrites the value from the source type's binary representation into the destination type's binary representation.  This step *may not* transform the value in any way.  If the result of the approximation is not representable, the conversion *must* fail.The major reason for this formulation is to exactly define what happens when converting between floating point and integer types.  Often, it is unclear what happens to floating point values beyond the range of the target integer type.  Do they saturate, wrap, or cause a failure?With this formulation, it is well-defined: if a floating point value is outside the representable range, the conversion fails.  This allows users to distinguish between approximation and range violation, and act accordingly."],["ApproxInto","This is the dual of `ApproxFrom`; see that trait for information.Where possible, prefer *using* this trait over `ApproxFrom` for generic constraints, but prefer *implementing* `ApproxFrom`."],["ApproxScheme","This trait is used to mark approximation scheme types."],["ConvAsUtil","This extension trait exists to simplify using various conversions.If there is more than one `ApproxFrom` implementation for a given type, a simple call to `approx_into` may not be uniquely resolvable.  Due to the position of the scheme parameter (on the trait itself), it is cumbersome to specify which scheme you wanted.The destination type is inferred from context.See also the `ConvUtil` trait.**Note**: There appears to be a bug in `rustdoc`'s output.  This trait is implemented *for all* types, though the methods are only available for types where the appropriate conversions are defined."],["ConvUtil","This extension trait exists to simplify using various conversions.If there is more than one implementation for a given type/trait pair, a simple call to `*_into` may not be uniquely resolvable.  Due to the position of the type parameter (on the trait itself), it is cumbersome to specify the destination type.  A similar problem exists for approximation schemes.See also the `ConvAsUtil` trait.**Note**: There appears to be a bug in `rustdoc`'s output.  This trait is implemented *for all* types, though the methods are only available for types where the appropriate conversions are defined."],["TryFrom","This trait is used to perform a conversion between different semantic types which might fail.Where possible, prefer *implementing* this trait over `TryInto`, but prefer *using* `TryInto` for generic constraints.DetailsTypically, this should be used in cases where you are converting between values whose ranges and/or representations only partially overlap.  That the conversion may fail should be a reasonably expected outcome.  A standard example of this is converting from integers to enums of unitary variants."],["TryInto","This is the dual of `TryFrom`; see that trait for information.Where possible, prefer *using* this trait over `TryFrom` for generic constraints, but prefer *implementing* `TryFrom`."],["ValueFrom","This trait is used to perform an exact, value-preserving conversion.Where possible, prefer *implementing* this trait over `ValueInto`, but prefer *using* `ValueInto` for generic constraints.DetailsImplementations of this trait should be reflexive, associative and commutative (in the absence of conversion errors).  That is, all possible cycles of `ValueFrom` conversions (for which each \"step\" has a defined implementation) should produce the same result, with a given value either being \"round-tripped\" exactly, or an error being produced."],["ValueInto","This is the dual of `ValueFrom`; see that trait for information.Where possible, prefer *using* this trait over `ValueFrom` for generic constraints, but prefer *implementing* `ValueFrom`."]]});