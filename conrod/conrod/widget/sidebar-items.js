initSidebarItems({"enum":[["Index","An index either given in the form of a publicly instantiated `Widget`'s `WidgetId`, or an internally instantiated `Widget`'s `NodeIndex`,"],["MaybeParent","The builder argument for the **Widget**'s parent."]],"mod":[["button",""],["canvas",""],["drag",""],["drop_down_list",""],["envelope_editor",""],["label",""],["matrix",""],["number_dialer",""],["scroll",""],["slider",""],["split",""],["tabs",""],["text_box",""],["toggle",""],["xy_pad",""]],"struct":[["CommonBuilder","A struct containing builder data common to all **Widget** types. This type allows us to do a blanket impl of **Positionable** and **Sizeable** for `T: Widget`."],["CommonState","A wrapper around state that is common to all **Widget** types."],["DrawArgs","Arguments for the **Widget::draw** method in a struct to simplify the method signature."],["Floating","State necessary for \"floating\" (pop-up style) widgets."],["Id","Unique, public widget identifier. Each widget must use a unique `WidgetId` so that it's state can be cached within the `Ui` type. The reason we use a usize is because widgets are cached within a `Graph` whose max number of `Node`s is indexed by usize."],["KidArea","The area upon which a **Widget**'s child widgets will be placed."],["KidAreaArgs","Arguments to the **Widget::kid_area** method in a struct to simplify the method signature."],["State","A wrapper around a **Widget**'s unique **Widget::State**."],["UiCell","A wrapper around a `Ui` that only exposes the functionality necessary for the **Widget::update** method."],["UpdateArgs","Arguments for the **Widget::update** method in a struct to simplify the method signature."]],"trait":[["Widget","A trait to be implemented by all **Widget** types."]]});