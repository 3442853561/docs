initSidebarItems({"enum":[["Index","An index either given in the form of a publicly instantiated `Widget`'s `WidgetId`, or an internally instantiated `Widget`'s `NodeIndex`,"],["MaybeParent","The builder argument for the **Widget**'s parent."]],"fn":[["default_x_dimension","Determines the default **Dimension** for a **Widget**.This function checks for a default dimension in the following order. 1. Check for a default value within the **Ui**'s **Theme**. 2. Otherwise attempts to copy the dimension of the previously set widget if there is one. 3. Otherwise attempts to copy the dimension of our parent widget. 4. If no parent widget can be inferred, the window dimensions are used.This is called by the default implementations of **Widget::default_x_dimension**.If you wish to override **Widget::default_x_dimension**, feel free to call this function internally if you partly require the bahaviour of the default implementations."],["default_y_dimension","Determines the default **Dimension** for a **Widget**.This function checks for a default dimension in the following order. 1. Check for a default value within the **Ui**'s **Theme**. 2. Otherwise attempts to copy the dimension of the previously set widget if there is one. 3. Otherwise attempts to copy the dimension of our parent widget. 4. If no parent widget can be inferred, the window dimensions are used.This is called by the default implementations of **Widget::default_y_dimension**.If you wish to override **Widget::default_y_dimension**, feel free to call this function internally if you partly require the bahaviour of the default implementations."]],"mod":[["button",""],["canvas",""],["drag","Types and functionality related to the dragging behaviour of Widgets."],["drop_down_list",""],["envelope_editor",""],["matrix",""],["number_dialer",""],["primitive",""],["scroll","Scroll related types and logic."],["slider",""],["tabs",""],["text_box",""],["title_bar",""],["toggle",""],["xy_pad",""]],"struct":[["CommonBuilder","A struct containing builder data common to all **Widget** types.This type also allows us to do a blanket impl of **Positionable** and **Sizeable** for `T: Widget`.When Rust gets some sort of field inheritance feature, this will most likely be refactored to take advantage of that."],["CommonState","A wrapper around state that is common to all **Widget** types."],["CommonStyle","Styling and positioning data that is common between all widget types."],["Floating","State necessary for \"floating\" (pop-up style) widgets."],["Id","Unique, public widget identifier. Each widget must use a unique `WidgetId` so that it's state can be cached within the `Ui` type. The reason we use a usize is because widgets are cached within a `Graph` whose max number of `Node`s is indexed by usize."],["IndexSlot","A small cache for a single unique **NodeIndex**.This should be used by **Widget**s within their unique **State** for instantiating their own unique widgets.This should reduce the need for users to directly call `UiCell::new_unique_node_index` and in turn reduce related mistakes (i.e. accidentally calling it and growing the graph unnecessarily)."],["KidArea","The area upon which a **Widget**'s child widgets will be placed."],["KidAreaArgs","Arguments to the **Widget::kid_area** method in a struct to simplify the method signature."],["State","A wrapper around a **Widget**'s unique **Widget::State**.This type is used to provide limited access to the **Widget::State** within the **Widget::update** method (to which it is passed via the **UpdateArgs**).The type provides only two methods. One for viewing the state, the other for mutating it.We do this so that we can keep track of whether or not the **Widget::State** has been mutated (using an internal `has_updated` flag). This allows us to know whether or not we need to re-draw the **Widget**, without having to compare the previous and new **Widget::State**s."],["UiCell","A wrapper around a `Ui` that only exposes the functionality necessary for the **Widget::update** method.Its primary role is to allow for widget designers to compose their own unique **Widget**s from other **Widget**s by calling the **Widget::set** method within their own **Widget**'s update method.It also provides methods for accessing the **Ui**'s **Theme**, **GlyphCache** and **UserInput** via immutable reference.BTW - if you have a better name for this type, please post an issue or PR! \"Cell\" was the best I could come up with as it's kind of like a jail cell for the **Ui** - restricting a user's access to it."],["UpdateArgs","Arguments for the **Widget::update** method in a struct to simplify the method signature."]],"trait":[["Widget","A trait to be implemented by all **Widget** types.A type that implements **Widget** can be thought of as a collection of arguments to the **Widget**'s **Widget::update** method. They type itself is not stored between updates, but rather is used to update an instance of the **Widget**'s **Widget::State**, which *is* stored.Methods that *must* be overridden:common common_mut unique_kind init_state style update Methods that can be optionally overridden:default_x_position default_y_position default_width default_height drag_area kid_area Methods that should not be overridden:floating scroll_kids scroll_kids_vertically scroll_kids_horizontally place_widget_on_kid_area parent no_parent set"]],"type":[["Kind","A unique identifier for a **Widget** type.Note: This might be replaced with **Any::get_type_id** when it stabilises."]]});