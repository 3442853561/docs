initSidebarItems({"enum":[["Align","The orientation of **Align**ment along some **Axis**."],["Axis","Represents either **Axis** in the 2-dimensional plane."],["Corner","Either of the four corners of a **Rect**."],["Dimension","The length of a **Widget** over either the *x* or *y* axes.This type is used to represent the different ways in which a dimension may be sized.See the **Sizeable** trait for methods that allow for setting the `x` and `y` **Dimension**s in various ways.Note that **Sizeable** is implemented for *all* types that implement **Widget**."],["Direction","Directionally positioned, normally relative to some other widget."],["Edge","Represents either the **Start** or **End** **Edge** of a **Range**."],["Framing","To be used as a parameter for defining the aesthetic of the widget frame."],["MaybeParent","The builder argument for the **Widget**'s parent."],["MouseButtonPosition","Represents the current state of a mouse button."],["Place","Place the widget at a position on some other widget."],["Position","Some **Position** of some **Widget** along a single axis.**Position**s for both the *x* and *y* axes are stored internally within the **widget::CommonBuilder** type, allowing all widgets to be positioned in a variety of different ways.See the **Positionable** trait for methods that allow for setting the **Position**s in various ways.Note that **Positionable** is implemented for *all* types that implement **Widget**."],["ShapeStyle","The style for some 2D shape."],["WidgetIndex","An index either given in the form of a publicly instantiated `Widget`'s `WidgetId`, or an internally instantiated `Widget`'s `NodeIndex`,"],["Wrap","The way in which text should wrap around the width."]],"fn":[["default_x_dimension","Determines the default **Dimension** for a **Widget**.This function checks for a default dimension in the following order. 1. Check for a default value within the **Ui**'s **Theme**. 2. Otherwise attempts to copy the dimension of the previously set widget if there is one. 3. Otherwise attempts to copy the dimension of our parent widget. 4. If no parent widget can be inferred, the window dimensions are used.This is called by the default implementations of **Widget::default_x_dimension**.If you wish to override **Widget::default_x_dimension**, feel free to call this function internally if you partly require the bahaviour of the default implementations."],["default_y_dimension","Determines the default **Dimension** for a **Widget**.This function checks for a default dimension in the following order. 1. Check for a default value within the **Ui**'s **Theme**. 2. Otherwise attempts to copy the dimension of the previously set widget if there is one. 3. Otherwise attempts to copy the dimension of our parent widget. 4. If no parent widget can be inferred, the window dimensions are used.This is called by the default implementations of **Widget::default_y_dimension**.If you wish to override **Widget::default_y_dimension**, feel free to call this function internally if you partly require the bahaviour of the default implementations."]],"macro":[["builder_method!","A macro for simplifying implementation of methods for the `builder pattern`.See the `builder_methods! docs for more background and details."],["builder_methods!","A macro to simplify implementation of \"builder-pattern\" methods.The Builder PatternConrod (and much of the Rust ecosystem) makes extensive use of the builder pattern in order to provide an expressive widget API. After much iteration, we settled upon the builder pattern as the best approach to interacting with highly optional types, or in our case, widgets.Almost all widgets implement at least a few methods in order to take advantage of this pattern. We call them \"builder methods\".The builder pattern looks like this:This allows us to support large numbers of optionally specified parameters on widgets, rather than forcing a user to give them all as `Option` arguments to some function.builder_method!This macro allows you to easily implement any number of builder methods for either trait or direct implementations.Here's what implementing the color method for our `Button` now looks like:Breaking it downThe first `color` is an `ident` which specifies the name of the builder function. The preceding `pub` visiblity token is optional. The second `color` is the field of `self` to which we assign the given value when building. `Color` is the type which the builder method receives as an argument. The encapsulating `Some(*)` is optional, and can be removed for cases where the field itself is a normal type and not an `Option` type. Multiple `builder_methods!`We can also use the macro to implement multiple builder methods at once. The following is an example of this directly from conrod's `Tabs` widget implementation. It expands to 9 unique builder methods - one for every line.Note that the `builder_methods!` macro is designed to work harmony with `widget_style!` - a macro which simplifies implementation of a widget's associated `Style` type. If you are designing your own widget and you haven't looked at it yet, we recommend you check out the docs."],["widget_ids!","Generate a list of unique IDs given a list of identifiers.This is the recommended way of generating `WidgetId`s as it greatly lessens the chances of making errors when adding or removing widget ids.Each Widget must have its own unique identifier so that the `Ui` can keep track of its state between updates.To make this easier, we provide the `widget_ids` macro, which generates a unique `WidgetId` for each identifier given in the list.The `with n` syntax reserves `n` number of `WidgetId`s for that identifier rather than just one.This is often useful in the case that you need to set multiple Widgets in a loop or when using the `widget::Matrix`.Note: Make sure when that you remember to `#[macro_use]` if you want to use this macro - i.e.`#[macro_use] extern crate conrod;`Also, if your list has a large number of identifiers (~64 or more) you may find this macro hitting rustc's recursion limit (this will show as a compile error). To fix this you can try adding the following to your crate root.`#![recursion_limit=\"512\"]`This will raise the recursion limit from the default (~64) to 512. You should be able to set it to a higher number if you find it necessary."],["widget_style!","A macro for vastly simplifying the definition and implementation of a widget's associated `Style` type.For more information on the purpose of this `Style` type, see the associated `type Style` docs in the `Widget` trait documentation.Using the macro looks like this:An invocation of the macro expands into two things:A struct definition with the given name following the `style` token. An `impl Style` block with a `new` constructor as well as a style retrieval method for each given field. These retrieval methods do the following:Attempt to use the value at the field. If the field is `None`, attempts to retreive a default from the `widget_styling` map in the `Ui`'s current `Theme`. If no defaults were found, evaluates the given default expression (or `theme.field`). ExamplesThe following is a typical usage example for the `widget_style!` macro.And here is what it expands into:"]],"mod":[["backend","Traits and functionality related to Conrod's generic backend.These modules describe an interface allowing users to use their own graphics, events and character caching systems with Conrod.**Note:** Conrod currently heavily depends upon the piston graphics and event crates for enabling genericity over custom user backends. This dependency may change in the near future in favour of simplified conrod-specific backend trait."],["color","A library providing simple `Color` and `Gradient` types along with useful transformations and presets.Inspiration taken from elm-lang's color moduleModule for working with colors. Includes RGB and HSL creation, gradients and built-in names."],["drag","Types and functionality related to the dragging behaviour of Widgets."],["events","This module contains all the logic for handling input events and providing them to widgets. All user input is provided to the `Ui` in the form of `input::Input` events, which are continuously polled from the backend window implementation. These raw input events tent to be fairly low level. The `Ui` passes each of these events off to it's `GlobalInput`, which keeps track of the state of affairs for the entire `Ui`. `GlobalInput` will also aggregate the low level events into higher level ones. For instance, two events indicating that a mouse button was pressed then released would cause a new `UiEvent::MouseClick` to be generated. This saves individual widgets from having to interpret these themselves, thus freeing them from also having to store input state.Whenever there's an update, all of the events that have occured since the last update will be available for widgets to process. This is where the `InputProvider` trait comes in. The `InputProvider` trait provides many methods for conveniently filtering events that a widget would like to handle. There are two things that implement this trait. The first is `GlobalInput`, and the second is `WidgetInput`. `WidgetInput` is used to provide input events to a specific widget. It filters events that don't apply to the widget, and all events provided by `WidgetIput` will have all coordinates in the widget's own local coordinate system. `GlobalInput`, on the other hand, will never filter out any events, and will always provide them with coordinates relative to the window."],["glyph_cache","Conrod's character caching API.Provides types and functionality related character texture caching and text dimensioning."],["graph","Conrod uses a directed acyclic graph to manage both storing widgets and describing their relationships.The primary type of interest in this module is the **Graph** type."],["guide","**The Conrod Guide**Table of Contents**What is Conrod?** A Brief Summary Screenshots and Videos Feature Overview Available Widgets Primitive Widgets Common Use Widgets Immediate Mode What is it? Why use it? Is Conrod Immediate or Retained? The Builder Pattern **Getting Started** Installing Rust and Cargo Installing FreeType Running the Conrod Examples **Let's Create a GUI** Setup a Basic Window (using piston_window) Conrod Setup Instantiating Widgets Widget Positioning and Layout **Using and Customising Themes** What is a `Theme`? Custom Themes Serializing Themes **Designing Custom Widgets (using the Widget trait)** The `Widget` trait The `widget_style!` macro The `builder_methods!` macro Making a `Button` widget **Custom Graphics and Window Backends** Demonstration of Backend Implementation (using glium and glutin) **Internals** The `Ui`'s Widget `Graph` `Ui::set_widgets` - How does it work? **FAQ**"],["scroll","Scroll related types and logic."],["theme","Types a functionality for handling Canvas and Widget theming."],["utils","Various utility functions used throughout Conrod."]],"struct":[["Background","A type for drawing a colored window background."],["Button","A pressable button widget whose reaction is triggered upon release."],["ButtonStyle","Unique styling for the Button."],["Canvas","**Canvas** is designed to be a \"container\"-like \"parent\" widget that simplifies placement of \"children\" widgets.Widgets can be placed on a **Canvas** in a variety of ways using methods from the **Positionable** trait.**Canvas** provides methods for padding the kid widget area which can make using the **Place**-related **Positionable** methods a little easier.A **Canvas** can also be divided into a sequence of smaller **Canvas**ses using the `.flow_*` methods. This creates a kind of **Canvas** tree, where each \"split\" can be sized using the `.length` or `.length_weight` methods.See the `canvas.rs` example for a demonstration of the **Canvas** type."],["CanvasStyle","Unique styling for the Canvas."],["Circle","A tiny wrapper around the **Oval** widget type."],["CommonBuilder","A struct containing builder data common to all **Widget** types.This type also allows us to do a blanket impl of **Positionable** and **Sizeable** for `T: Widget`.When Rust gets some sort of field inheritance feature, this will most likely be refactored to take advantage of that."],["CommonState","A wrapper around state that is common to all **Widget** types."],["CommonStyle","Styling and positioning data that is common between all widget types."],["DropDownList","Displays a given `Vec<String>` as a selectable drop down menu. It's reaction is triggered upon selection of a list item."],["DropDownListStyle","Styling for the DropDownList, necessary for constructing its renderable Element."],["EnvelopeEditor","Used for editing a series of 2D Points on a cartesian (X, Y) plane within some given range.Useful for things such as oscillator/automation envelopes or any value series represented periodically."],["EnvelopeEditorStyle","Styling for the EnvelopeEditor, necessary for constructing its renderable Element."],["Floating","State necessary for \"floating\" (pop-up style) widgets."],["FramedRectangle","A filled rectangle widget that may or may not have some frame."],["FramedRectangleStyle","Unique styling for the **FramedRectangle** widget."],["IndexSlot","A small cache for a single unique **NodeIndex**.This should be used by **Widget**s within their unique **State** for instantiating their own unique widgets.This should reduce the need for users to directly call `UiCell::new_unique_node_index` and in turn reduce related mistakes (i.e. accidentally calling it and growing the graph unnecessarily)."],["KidArea","The area upon which a **Widget**'s child widgets will be placed."],["KidAreaArgs","Arguments to the **Widget::kid_area** method in a struct to simplify the method signature."],["Line","A simple, non-interactive widget for drawing a single straight Line."],["LineStyle","Unique styling for a Line widget."],["Mouse","Represents the current state of the Mouse."],["MouseButtonState","The current state of a Mouse button."],["MouseScroll","The amount of scrolling that has occurred since the last render event."],["NumberDialer","A widget for precision control over any digit within a value.The reaction is triggered when the value is updated or if the mouse button is released while the cursor is above the widget."],["NumberDialerStyle","Unique graphical styling for the NumberDialer."],["Oval","A simple, non-interactive widget for drawing a single **Oval**."],["Padding","The distance between the inner edge of a frame and the outer edge of the inner content."],["PointPath","A simple, non-interactive widget for drawing a series of lines and/or points."],["Polygon","A basic, non-interactive, arbitarry **Polygon** widget.The **Polygon** is described by specifying its corners in order.**Polygon** will automatically close all shapes, so the given list of points does not need to start and end with the same position."],["PositionMatrix","A type to simplify placement of various widgets in a matrix or grid layout."],["Range","Some start and end position along a single axis.As an example, a **Rect** is made up of two **Range**s; one along the *x* axis, and one along the *y* axis."],["Rect","Defines a Rectangle's bounds across the x and y axes.This is a conrod-specific Rectangle in that it's designed to help with layout."],["Rectangle","A basic, non-interactive rectangle shape widget."],["Slider","Linear value selection. If the slider's width is greater than it's height, it will automatically become a horizontal slider, otherwise it will be a vertical slider. Its reaction is triggered if the value is updated or if the mouse button is released while the cursor is above the rectangle."],["SliderStyle","Graphical styling unique to the Slider widget."],["Tabs","A wrapper around a list of canvasses that displays thema s a list of selectable tabs."],["TabsStyle","The styling for Canvas Tabs."],["Text","Displays some given text centred within a rectangular area.By default, the rectangular dimensions are fit to the area occuppied by the text.If some horizontal dimension is given, the text will automatically wrap to the width and align in accordance with the produced **Align**."],["TextBox","A widget for displaying and mutating a given one-line text `String`. It's reaction is triggered upon pressing of the `Enter`/`Return` key."],["TextBoxStyle","Unique graphical styling for the TextBox."],["TextStyle","The styling for a **Text**'s graphics."],["TitleBar","A simple title bar widget that automatically sizes itself to the top of some other widget."],["TitleBarStyle","Unique styling for the **TitleBar** widget."],["Toggle","A pressable widget for toggling the state of a bool.Like the Button widget, it's reaction is triggered upon release and will return the new bool state.Note that the Toggle will not mutate the bool for you, you should do this yourself within the react function."],["ToggleStyle","Styling for the Toggle including coloring, framing and labelling."],["Ui","`Ui` is the most important type within Conrod and is necessary for rendering and maintaining widget state.Ui Handles the following:Contains the state of all widgets which can be indexed via their widget::Index. Stores rendering state for each widget until the end of each render cycle. Contains the theme used for default styling of the widgets. Maintains the latest user input state (for mouse and keyboard). Maintains the latest window dimensions."],["UiCell","A wrapper around a `Ui` that only exposes the functionality necessary for the **Widget::update** method.Its primary role is to allow for widget designers to compose their own unique **Widget**s from other **Widget**s by calling the **Widget::set** method within their own **Widget**'s update method.It also provides methods for accessing the **Ui**'s **Theme**, **GlyphCache** and **UserInput** via immutable reference.BTW - if you have a better name for this type, please post an issue or PR! \"Cell\" was the best I could come up with as it's kind of like a jail cell for the **Ui** - restricting a user's access to it."],["UpdateArgs","Arguments for the **Widget::update** method in a struct to simplify the method signature."],["UserInput","A wrapper over the current user input state."],["WidgetCommonState","A wrapper around state that is common to all **Widget** types."],["WidgetId","Unique, public widget identifier. Each widget must use a unique `WidgetId` so that it's state can be cached within the `Ui` type. The reason we use a usize is because widgets are cached within a `Graph` whose max number of `Node`s is indexed by usize."],["WidgetMatrix","Draw a matrix of any rectangular widget type, where the matrix will provide a function with the widget number, it's `rows` and `cols` position, the width and height for the widget and the location at which the widget should be drawn."],["WidgetState","A wrapper around a **Widget**'s unique **Widget::State**.This type is used to provide limited access to the **Widget::State** within the **Widget::update** method (to which it is passed via the **UpdateArgs**).The type provides only two methods. One for viewing the state, the other for mutating it.We do this so that we can keep track of whether or not the **Widget::State** has been mutated (using an internal `has_updated` flag). This allows us to know whether or not we need to re-draw the **Widget**, without having to compare the previous and new **Widget::State**s."],["XYPad","Used for displaying and controlling a 2D point on a cartesian plane within a given range.Its reaction is triggered when the value is updated or if the mouse button is released while the cursor is above the rectangle."],["XYPadStyle","Unique graphical styling for the XYPad."]],"trait":[["CharacterCache","Stores characters in a buffer and loads them by demand."],["EnvelopePoint","`EnvPoint` must be implemented for any type that is used as a 2D point within the EnvelopeEditor."],["Frameable","Widgets that may display a frame."],["Graphics","Implemented by all graphics back-ends.An example back-end using raw OpenGLBy default, this design uses triangles as graphics primitives. This is supported by all GPUs and easy to implement in shader languages.Default trait methods can be overridden for better performance or higher quality.When drawing, use this trait as generic constraint:"],["Labelable","Widgets that may display some label."],["Positionable","Widgets that are positionable.A **Position** is stored internally within the **widget::CommonBuilder** type, allowing all widgets to be positioned in a variety of different ways.Thus, **Positionable** can be implemented for *all* types that implement **Widget**."],["Sizeable","Widgets that support different dimensions."],["Widget","A trait to be implemented by all **Widget** types.A type that implements **Widget** can be thought of as a collection of arguments to the **Widget**'s **Widget::update** method. They type itself is not stored between updates, but rather is used to update an instance of the **Widget**'s **Widget::State**, which *is* stored.Methods that *must* be overridden:common common_mut unique_kind init_state style update Methods that can be optionally overridden:default_x_position default_y_position default_width default_height drag_area kid_area Methods that should not be overridden:floating scroll_kids scroll_kids_vertically scroll_kids_horizontally place_widget_on_kid_area parent no_parent set"]],"type":[["Depth","The depth at which the widget will be rendered.This determines the order of rendering where widgets with a greater depth will be rendered first.0.0 is the default depth."],["Dimensions","General use 2D spatial dimensions."],["FontSize","Font size used throughout Conrod."],["Margin","The margin for some `Place`ment on either end of an axis."],["Point","General use 2D spatial point."],["Scalar","An alias over the Scalar type used throughout Conrod.This type is primarily used for spatial dimensions and positioning."],["WidgetKind","A unique identifier for a **Widget** type.Note: This might be replaced with **Any::get_type_id** when it stabilises."]]});