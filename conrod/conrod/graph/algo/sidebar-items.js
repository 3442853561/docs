initSidebarItems({"fn":[["cropped_area_of_widget","The rectangle that represents the maximum visible area for the widget with the given index.Specifically, this considers the cropped scroll area for all parents.Otherwise, return None if the widget is hidden."],["cropped_area_of_widget_within_depth","The rectangle that represents the maximum visible area for the widget with the given index.This specifically considers the cropped scroll area for all parents until (and not including) the deepest_parent_idx is reached.Otherwise, return None if the widget is hidden."],["kids_bounding_box","Find the absolute `Rect` that bounds all widgets that are `Depth` children of the widget at the given `idx`.FIXME: This currently uses call stack recursion to do a depth-first search through all depth_children for the total bounding box. This should use a proper `Dfs` type with it's own stack for safer traversal that won't blow the stack on hugely deep GUIs."],["pick_scrollable_widget","If the given **Point** is currently over a scrollable widget, return an index to that widget.This function assumes that the given `depth_order` is up-to-date for the given `graph`."],["pick_widget","If the given Point is currently on a Widget, return an index to that widget.If the picked widget has a **Graphic** parent, that parent's index will be returned instead.This function assumes that the given `depth_order` is up-to-date for the given `graph`."],["scroll_offset","Return the `scroll_offset` for the widget at the given index.The offset is retrieved from the widget that is the immediate `depth_parent` of the widget at the given `idx` unless:the immediate `depth_parent` of `idx` is also a `graphic_parent` to `idx`. In this case, `NO_OFFSET` will be returned, as child widgets that are graphical elements of their parents should not be affected by scrolling. one of the position parents also has the same `depth_parent`. In this case, `NO_OFFSET` will be returned, as we know that our scroll offset has already been applied via the widget to which we are relatively positioned."]]});