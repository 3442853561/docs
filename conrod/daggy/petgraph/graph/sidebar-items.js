initSidebarItems({"fn":[["edge_index","Short version of `EdgeIndex::new`"],["node_index","Short version of `NodeIndex::new`"]],"struct":[["Edge","The graph's edge type."],["EdgeIndex","Edge identifier."],["EdgeIndices","Iterator over the edge indices of a graph."],["EdgeWeightsMut","Iterator yielding mutable access to all edge weights."],["Edges","Iterator over the edges of a node."],["Externals","An iterator over either the nodes without edges to them or from them."],["Graph","`Graph<N, E, Ty, Ix>` is a graph datastructure using an adjacency list representation.`Graph` is parameterized over:Associated data `N` for nodes and `E` for edges, called *weights*. The associated data can be of arbitrary type. Edge type `Ty` that determines whether the graph edges are directed or undirected. Index type `Ix`, which determines the maximum size of the graph. The graph uses **O(|V| + |E|)** space, and allows fast node and edge insert, efficient graph search and graph algorithms. It implements **O(e')** edge lookup and edge and node removals, where **e'** is some local measure of edge count. Based on the graph datastructure used in rustc.Here's an example of building a graph with directed edges, and below an illustration of how it could be rendered with graphviz (graphviz rendering is not a part of petgraph):![graph-example](graph-example.svg)Graph IndicesThe graph maintains indices for nodes and edges, and node and edge weights may be accessed mutably. Indices range in a compact interval, for example for *n* nodes indices are 0 to *n* - 1 inclusive.`NodeIndex` and `EdgeIndex` are types that act as references to nodes and edges, but these are only stable across certain operations. **Adding nodes or edges keeps indices stable. Removing nodes or edges may shift other indices.** Removing a node will force the last node to shift its index to take its place. Similarly, removing an edge shifts the index of the last edge.The `Ix` parameter is `u32` by default. The goal is that you can ignore this parameter completely unless you need a very big graph -- then you can use `usize`.Pros and Cons of IndicesThe fact that the node and edge indices in the graph each are numbered in compact intervals (from 0 to *n* - 1 for *n* nodes) simplifies some graph algorithms.You can select graph index integer type after the size of the graph. A smaller size may have better performance.Using indices allows mutation while traversing the graph, see `Dfs`, and `.neighbors(a).detach()`.You can create several graphs using the equal node indices but with differing weights or differing edges.The `Graph` is a regular rust collection and is `Send` and `Sync` (as long as associated data `N` and `E` are).Some indices shift during node or edge removal, so that is a drawback of removing elements. Indices don't allow as much compile time checking as references."],["Neighbors","Iterator over the neighbors of a node.Iterator element type is `NodeIndex<Ix>`.Created with `.neighbors()`, `.neighbors_directed()` or `.neighbors_undirected()`."],["Node","The graph's node type."],["NodeIndex","Node identifier."],["NodeIndices","Iterator over the node indices of a graph."],["NodeWeightsMut","Iterator yielding mutable access to all node weights."],["WalkEdges","**Deprecated.**A “walker” object that can be used to step through the edge list of a node.See *.walk_edges_directed()* for more information."],["WalkNeighbors","A “walker” object that can be used to step through the edge list of a node.Created with `.detach()`.The walker does not borrow from the graph, so it lets you step through neighbors or incident edges while also mutating graph weights, as in the following example:"]],"trait":[["GraphIndex","A  `GraphIndex` is a node or edge index."],["IndexType","Trait for the unsigned integer type used for node and edge indices.Marked `unsafe` because: the trait must faithfully preseve and convert index values."]],"type":[["DefIndex",""]]});