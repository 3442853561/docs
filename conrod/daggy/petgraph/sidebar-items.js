initSidebarItems({"enum":[["Directed","Marker type for a directed graph."],["EdgeDirection","Edge direction"],["Undirected","Marker type for an undirected graph."]],"mod":[["algo","Graph algorithms.It is a goal to gradually migrate the algorithms to be based on graph traits so that they are generally applicable. For now, most of these use only the **Graph** type."],["dot","Simple graphviz dot file format output."],["graph","`Graph<N, E, Ty, Ix>` is a graph datastructure using an adjacency list representation."],["graphmap","`GraphMap<N, E>` is an undirected graph where node values are mapping keys."],["unionfind","`UnionFind<K>` is a disjoint-set data structure."],["visit","Graph visitor algorithms."]],"struct":[["Bfs","A breadth first search (BFS) of a graph.Using a **Bfs** you can run a traversal over a graph while still retaining mutable access to it, if you use it like the following example:**Note:** The algorithm may not behave correctly if nodes are removed during iteration. It may not necessarily visit added nodes or edges."],["BfsIter","An iterator for a breadth first traversal of a graph."],["Dfs","A depth first search (DFS) of a graph.Using a **Dfs** you can run a traversal over a graph while still retaining mutable access to it, if you use it like the following example:**Note:** The algorithm may not behave correctly if nodes are removed during iteration. It may not necessarily visit added nodes or edges."],["DfsIter","An iterator for a depth first traversal of a graph."],["Graph","`Graph<N, E, Ty, Ix>` is a graph datastructure using an adjacency list representation.`Graph` is parameterized over:Associated data `N` for nodes and `E` for edges, called *weights*. The associated data can be of arbitrary type. Edge type `Ty` that determines whether the graph edges are directed or undirected. Index type `Ix`, which determines the maximum size of the graph. The graph uses **O(|V| + |E|)** space, and allows fast node and edge insert, efficient graph search and graph algorithms. It implements **O(e')** edge lookup and edge and node removals, where **e'** is some local measure of edge count. Based on the graph datastructure used in rustc.Here's an example of building a graph with directed edges, and below an illustration of how it could be rendered with graphviz (graphviz rendering is not a part of petgraph):![graph-example](graph-example.svg)Graph IndicesThe graph maintains indices for nodes and edges, and node and edge weights may be accessed mutably. Indices range in a compact interval, for example for *n* nodes indices are 0 to *n* - 1 inclusive.`NodeIndex` and `EdgeIndex` are types that act as references to nodes and edges, but these are only stable across certain operations. **Adding nodes or edges keeps indices stable. Removing nodes or edges may shift other indices.** Removing a node will force the last node to shift its index to take its place. Similarly, removing an edge shifts the index of the last edge.The `Ix` parameter is `u32` by default. The goal is that you can ignore this parameter completely unless you need a very big graph -- then you can use `usize`.Pros and Cons of IndicesThe fact that the node and edge indices in the graph each are numbered in compact intervals (from 0 to *n* - 1 for *n* nodes) simplifies some graph algorithms.You can select graph index integer type after the size of the graph. A smaller size may have better performance.Using indices allows mutation while traversing the graph, see `Dfs`, and `.neighbors(a).detach()`.You can create several graphs using the equal node indices but with differing weights or differing edges.The `Graph` is a regular rust collection and is `Send` and `Sync` (as long as associated data `N` and `E` are).Some indices shift during node or edge removal, so that is a drawback of removing elements. Indices don't allow as much compile time checking as references."],["GraphMap","`GraphMap<N, E>` is an undirected graph, with generic node values `N` and edge weights `E`.It uses an combined adjacency list and sparse adjacency matrix representation, using **O(|V| + |E|)** space, and allows testing for edge existance in constant time.The node type `N` must implement `Copy` and will be used as node identifier, duplicated into several places in the data structure. It must be suitable as a hash table key (implementing `Eq + Hash`). The node type must also implement `Ord` so that the implementation can order the pair (`a`, `b`) for an edge connecting any two nodes `a` and `b`.`GraphMap` does not allow parallel edges, but self loops are allowed."]],"trait":[["EdgeType","A graph's edge type determines whether is has directed edges or not."],["IntoWeightedEdge","Convert an element like `(i, j)` or `(i, j, w)` into a triple of source, target, edge weight.For `Graph::from_edges` and `GraphMap::from_edges`."]]});